<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>AR Gallery Pro - Ultra Performance</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    
    <link rel="manifest" href="manifest.json">
    <link href="css/Vazirmatn-font-face.css" rel="stylesheet" type="text/css" />

    <script src="js/mediapipe/selfie_segmentation.js" defer></script>
    <script src="js/webxr-polyfill.js" defer></script> 
    
    <style>
        body { font-family: 'Vazirmatn', sans-serif; margin: 0; overflow: hidden; background-color: #000; user-select: none; -webkit-tap-highlight-color: transparent; color: white; }
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; transition: opacity 0.3s; }
        .ui-hidden #ui-layer { opacity: 0; pointer-events: none; }
        .ui-top-bar { padding: 15px; display: flex; justify-content: space-between; pointer-events: auto; }
        .ui-top-bar-left, .ui-top-bar-right { display: flex; gap: 10px; }
        .ui-bottom-controls { padding: 10px 15px; background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); pointer-events: auto; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; width: 100%; box-sizing: border-box; padding-bottom: 20px; }
        .btn-icon { background: rgba(40, 40, 40, 0.85); border: 1px solid rgba(255, 255, 255, 0.2); color: white; width: 42px; height: 42px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s, background 0.3s; pointer-events: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.3); padding: 0; margin: 0; }
        .btn-icon:active { transform: scale(0.9); background: rgba(255, 255, 255, 0.3); }
        .btn-icon.active-mode { background: #3b82f6; border-color: #60a5fa; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        .btn-icon.exit-mode { background: rgba(220, 38, 38, 0.8); border-color: #f87171; }
        .hidden { display: none !important; }
        .btn-label { background: #2563eb; color: white; padding: 8px 16px; border-radius: 30px; display: flex; align-items: center; gap: 10px; font-weight: bold; cursor: pointer; transition: transform 0.2s; pointer-events: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.3); font-size: 0.9rem; }
        .controls-row { display: flex; gap: 10px; align-items: center; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 40px; flex-wrap: wrap; justify-content: center; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; border: 1px solid white; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 200; display: none; justify-content: center; align-items: center; padding: 20px; pointer-events: auto; box-sizing: border-box; backdrop-filter: blur(5px); }
        .modal-content { background: #1f2937; color: white; padding: 25px; border-radius: 20px; max-width: 400px; width: 100%; border: 1px solid #374151; text-align: right; box-shadow: 0 10px 25px rgba(0,0,0,0.5); overflow-y: auto; max-height: 80vh; -webkit-overflow-scrolling: touch; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #374151; padding-bottom: 10px; }
        .modal-title { font-size: 1.1rem; font-weight: bold; color: #60a5fa; margin: 0; }
        #temp-reveal-btn { position: fixed; top: 80px; right: 20px; z-index: 100; display: none; padding: 12px 25px; background: rgba(37, 99, 235, 0.9); color: white; font-weight: bold; font-size: 1rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        #touch-status { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.6); color: white; padding: 10px 20px; border-radius: 20px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 20; font-size: 0.9rem; }
        .radio-group { display: flex; flex-direction: column; gap: 15px; margin-top: 10px; }
        .radio-item { display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px; }
        .radio-item:hover { background: rgba(255,255,255,0.1); }
        .radio-item input { width: 20px; height: 20px; accent-color: #3b82f6; }
        #ar-container { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; }
        #ar-container canvas { display: block; }
        #custom-ar-btn { position: absolute; bottom: 80px; right: 30px; padding: 12px 30px; border: 1px solid rgba(255,255,255,0.5); border-radius: 25px; background: rgba(0,0,0,0.7); color: white; font-family: 'Vazirmatn', sans-serif; font-size: 14px; font-weight: bold; z-index: 50; cursor: pointer; box-shadow: 0 0 15px rgba(0,0,0,0.5); transition: all 0.2s; }
        #custom-ar-btn:active { transform: scale(0.95); background: rgba(37, 99, 235, 0.8); }
        .w-full { width: 100%; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .gap-3 { gap: 12px; }
        .text-xs { font-size: 0.75rem; }
        .text-white { color: white; }
        .bg-black\/60 { background-color: rgba(0,0,0,0.6); }
        .rounded-full { border-radius: 9999px; }
        .p-2 { padding: 0.5rem; }
        .flex-grow { flex-grow: 1; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 0.5rem; } 
        .justify-end { justify-content: flex-end; }
        .flex-col { flex-direction: column; }
        #cube-shape-btn { width: 50px; height: 50px; }
        #cube-shape-btn svg { width: 26px; height: 26px; }
    </style>
</head>
<body id="app-body">

    <div id="ar-container"></div>
    <div id="touch-status">وضعیت</div>
    <button id="custom-ar-btn">ورود به AR (حالت بهینه)</button>
    <button id="temp-reveal-btn">آشکارسازی دکمه‌ها</button>

    <div id="ui-layer">
        <div class="ui-top-bar">
            <div class="ui-top-bar-left">
                <button id="exit-btn" class="btn-icon exit-mode" title="خروج">
                   <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M10 12.5a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v2a.5.5 0 0 0 1 0v-2A1.5 1.5 0 0 0 9.5 2h-8A1.5 1.5 0 0 0 0 3.5v9A1.5 1.5 0 0 0 1.5 14h8a1.5 1.5 0 0 0 1.5-1.5v-2a.5.5 0 0 0-1 0v2z"/><path fill-rule="evenodd" d="M15.854 8.354a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L14.293 7.5H5.5a.5.5 0 0 0 0 1h8.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3z"/></svg>
                </button>
                <button id="about-btn" class="btn-icon" title="درباره ما"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/></svg></button>
                <button id="help-btn" class="btn-icon" title="راهنما"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/></svg></button>
                <button id="settings-btn" class="btn-icon" title="تنظیمات"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/><path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1-1.255-.52l-.094-.319z"/></svg></button>
            </div>
            <div class="ui-top-bar-right">
                <button id="clean-view-btn" class="btn-icon hidden" title="پنهان شدن دکمه‌ها"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/></svg></button>
                <button id="fullscreen-btn" class="btn-icon hidden" title="تمام صفحه"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5.5 0 0 1 .5 10v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1 0-1h4z"/></svg></button>
            </div>
        </div>

        <div class="ui-bottom-controls">
            <button id="file-input-label" class="btn-label" onclick="document.getElementById('file-input').click()">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M8 6.5a.5.5 0 0 1 .5.5v1.5H10a.5.5 0 0 1 0 1H8.5V11a.5.5 0 0 1-1 0V9.5H6a.5.5 0 0 1 0-1h1.5V7a.5.5 0 0 1 .5-.5z"/><path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/></svg>
                افزودن فایل
            </button>
            <input type="file" id="file-input" accept="image/*,video/*" class="hidden">

            <div id="controls-panel" class="controls-row hidden">
                <button id="remove-btn" class="btn-icon exit-mode" title="حذف">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                </button>
                <button id="cube-shape-btn" class="btn-icon" title="مکعب">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M0 0h16v16H0z" fill="none"/>
                        <path d="M8 0l8 4-8 4-8-4 8-4zM0 4v8l8 4v-8L0 4zm16 0l-8 4v8l8-4V4z" fill="currentColor" opacity="0.8"/>
                    </svg>
                </button>
                <div style="width: 100px; padding: 0 10px;">
                    <input type="range" id="scale-slider" min="0.1" max="5.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
    </div>

    <div id="about-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">درباره ما</h3>
                <span class="close-modal" style="cursor:pointer; font-size:1.5rem;">&times;</span>
            </div>
            <p>نسخه حرفه‌ای گالری واقعیت افزوده</p>
            <p>نسخه: 3.1.0 (Ultra Optimized)</p>
            <p>طراحی شده برای عملکرد بالا</p>
        </div>
    </div>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">راهنما</h3>
                <span class="close-modal" style="cursor:pointer; font-size:1.5rem;">&times;</span>
            </div>
            <ul style="padding-right: 20px; line-height: 1.8;">
                <li>برای افزودن تصویر یا ویدیو دکمه پایین را بزنید.</li>
                <li>برای جابجایی روی آبجکت بکشید.</li>
                <li>برای چرخش از دو انگشت استفاده کنید.</li>
                <li>برای تغییر سایز از اسلایدر یا پینچ دو انگشتی استفاده کنید.</li>
            </ul>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">تنظیمات</h3>
                <span class="close-modal" style="cursor:pointer; font-size:1.5rem;">&times;</span>
            </div>
            <div class="radio-group">
                <label class="radio-item"><input type="radio" name="ar-mode" value="hit-test" checked> قرارگیری روی سطوح (پیشرفته)</label>
                <label class="radio-item"><input type="radio" name="ar-mode" value="viewer"> نمایش ساده (Viewer)</label>
            </div>
            <div style="margin-top: 20px; font-size: 0.8rem; color: #9ca3af;">
                <p>حالت عملکرد: بهینه (Performance Mode)</p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from './three.module.js';

        // --- PERFORMANCE CONFIGURATION (OPTIMIZED) ---
        // Force medium precision for shaders to reduce GPU load on mobile
        THREE.ShaderChunk.precision = 'mediump';

        let camera, scene, renderer;
        let controller;
        let reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let currentMesh = null;
        let objects = [];
        let xrSession = null;
        
        // Interaction variables
        let isDragging = false;
        let gestureType = null; 
        let initialTouchX, initialTouchY, initialScale, initialRotation, initialDistance, initialAngle;
        let previousTouchX, previousTouchY;

        init();

        function init() {
            const container = document.createElement('div');
            document.getElementById('ar-container').appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // OPTIMIZATION: Light setup - kept simple
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            
            // OPTIMIZATION: Renderer Configuration
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, // Keep enabled for AR edge quality, but we limit PixelRatio below
                alpha: true,
                powerPreference: 'default', // 'high-performance' can drain battery, default is balanced
                precision: 'mediump' // Reduces fragment shader load
            });
            
            // CRITICAL OPTIMIZATION: Cap Pixel Ratio
            // Mobile devices often have DPR of 3 or 4. Rendering AR at that resolution kills performance.
            // Capping at 1.5 provides good visual quality with massive GPU savings.
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            
            // New Three.js Color Management
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            container.appendChild(renderer.domElement);

            // AR Button Logic
            document.getElementById('custom-ar-btn').addEventListener('click', async () => {
                if (navigator.xr) {
                    try {
                        const session = await navigator.xr.requestSession('immersive-ar', {
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                            domOverlay: { root: document.body }
                        });
                        renderer.xr.setReferenceSpaceType('local');
                        await renderer.xr.setSession(session);
                        xrSession = session;
                        document.getElementById('custom-ar-btn').style.display = 'none';
                        onSessionStarted(session);
                    } catch (e) {
                        console.error('AR Error:', e);
                        alert('دستگاه شما از AR پشتیبانی نمی‌کند یا مشکلی پیش آمده.');
                    }
                } else {
                    alert('مرورگر شما از WebXR پشتیبانی نمی‌کند.');
                }
            });

            // Reticle (The target circle)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Controller
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            window.addEventListener('resize', onWindowResize);
            
            // Setup UI Events
            setupUI();
            setupGestures(document.body); // Global gestures for AR overlay
        }

        function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            document.getElementById('ui-layer').classList.remove('ui-hidden');
            document.getElementById('clean-view-btn').classList.remove('hidden');
        }

        function onSessionEnded() {
            xrSession = null;
            hitTestSource = null;
            hitTestSourceRequested = false;
            document.getElementById('custom-ar-btn').style.display = 'block';
            document.getElementById('ui-layer').classList.add('ui-hidden');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onSelect() {
            if (reticle.visible && currentMesh) {
                // If we have a mesh ready to place
                const mesh = currentMesh.clone();
                reticle.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
                
                // Reset scale based on original aspect but keep reasonable AR size
                // We calculate a scale factor based on distance or fixed size
                const defaultScale = 0.5; 
                mesh.scale.set(defaultScale, defaultScale, defaultScale);

                // Correct Aspect Ratio for Videos/Images
                if (mesh.userData.aspect) {
                    if (mesh.userData.aspect > 1) {
                         mesh.scale.y = defaultScale / mesh.userData.aspect;
                    } else {
                         mesh.scale.x = defaultScale * mesh.userData.aspect;
                    }
                }

                scene.add(mesh);
                objects.push(mesh);
                
                // OPTIMIZATION: Disable matrix auto update for static objects if they don't move
                // However, we have gestures, so we keep it true.
                
                currentMesh = null; // Clear "pending" mesh
                document.getElementById('controls-panel').classList.add('hidden');
            }
        }

        // --- TEXTURE LOADING OPTIMIZATIONS ---
        
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            const isVideo = file.type.startsWith('video');

            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }

            if (isVideo) {
                const video = document.createElement('video');
                video.src = url;
                video.loop = true;
                video.muted = true; 
                video.playsInline = true;
                video.crossOrigin = "anonymous";
                video.play();

                const texture = new THREE.VideoTexture(video);
                
                // OPTIMIZATION: Critical for Video Performance
                texture.minFilter = THREE.LinearFilter; // Avoids Mipmap generation every frame (Huge CPU Saver)
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false; 
                texture.colorSpace = THREE.SRGBColorSpace;

                const geometry = new THREE.PlaneGeometry(1, 1);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide 
                });
                
                currentMesh = new THREE.Mesh(geometry, material);
                
                video.addEventListener('loadedmetadata', () => {
                    const aspect = video.videoWidth / video.videoHeight;
                    currentMesh.userData.aspect = aspect;
                    currentMesh.userData.isVideo = true;
                    // Initial preview position (in front of camera if not in AR)
                    currentMesh.position.set(0, 0, -2);
                    if (!xrSession) scene.add(currentMesh);
                    
                    document.getElementById('controls-panel').classList.remove('hidden');
                });

            } else {
                const loader = new THREE.TextureLoader();
                loader.load(url, (texture) => {
                    // OPTIMIZATION: Static Image
                    texture.colorSpace = THREE.SRGBColorSpace;
                    // Note: For static images, mipmaps are fine (calculated once)
                    
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.DoubleSide,
                        transparent: true // Only enable transparency if strictly needed (image has alpha)
                    });

                    currentMesh = new THREE.Mesh(geometry, material);
                    const aspect = texture.image.width / texture.image.height;
                    currentMesh.userData.aspect = aspect;
                    
                    currentMesh.position.set(0, 0, -2);
                    if (!xrSession) scene.add(currentMesh);

                    document.getElementById('controls-panel').classList.remove('hidden');
                });
            }
        });

        // Shape Button (Cube)
        document.getElementById('cube-shape-btn').addEventListener('click', () => {
             // Just a placeholder implementation for the button
             const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
             const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
             const mesh = new THREE.Mesh(geometry, material);
             
             if (currentMesh) scene.remove(currentMesh);
             currentMesh = mesh;
             currentMesh.userData.aspect = 1;
             
             if (!xrSession) {
                 mesh.position.set(0, 0, -2);
                 scene.add(mesh);
             }
             document.getElementById('controls-panel').classList.remove('hidden');
        });

        // --- ANIMATION LOOP ---

        renderer.setAnimationLoop(render);

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // --- UI & GESTURE UTILS ---

        function setupUI() {
            // Modal Logic
            const setupModal = (btnId, modalId) => {
                const btn = document.getElementById(btnId);
                const modal = document.getElementById(modalId);
                const close = modal.querySelector('.close-modal');
                btn.onclick = () => { modal.style.display = 'flex'; };
                close.onclick = () => { modal.style.display = 'none'; };
                window.onclick = (e) => { if (e.target == modal) modal.style.display = 'none'; };
            };
            
            setupModal('about-btn', 'about-modal');
            setupModal('help-btn', 'help-modal');
            setupModal('settings-btn', 'settings-modal');

            // Exit Button
            document.getElementById('exit-btn').addEventListener('click', () => {
                if (xrSession) xrSession.end();
            });

            // Clean View
            const uiLayer = document.getElementById('ui-layer');
            const revealBtn = document.getElementById('temp-reveal-btn');
            document.getElementById('clean-view-btn').addEventListener('click', () => {
                uiLayer.classList.add('ui-hidden');
                revealBtn.style.display = 'block';
            });
            revealBtn.addEventListener('click', () => {
                uiLayer.classList.remove('ui-hidden');
                revealBtn.style.display = 'none';
            });

            // Remove Button
            document.getElementById('remove-btn').addEventListener('click', () => {
                // Remove last added object or current selection
                if (objects.length > 0) {
                    const obj = objects.pop();
                    scene.remove(obj);
                    // Dispose geometry/material to free GPU memory
                    if(obj.geometry) obj.geometry.dispose();
                    if(obj.material) {
                        if(obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                } else if (currentMesh) {
                    scene.remove(currentMesh);
                    currentMesh = null;
                    document.getElementById('controls-panel').classList.add('hidden');
                }
            });

            // Scale Slider
            const slider = document.getElementById('scale-slider');
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (objects.length > 0) {
                     const obj = objects[objects.length - 1]; // Scale last object
                     obj.scale.set(val * 0.5, val * 0.5, val * 0.5); // simple uniform scale
                     // Restore aspect
                     if (obj.userData.aspect) {
                         if (obj.userData.aspect > 1) obj.scale.y /= obj.userData.aspect;
                         else obj.scale.x *= obj.userData.aspect;
                     }
                }
            });
        }

        // Simple Gesture Logic implementation (kept minimal for performance)
        function setupGestures(el) {
            el.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousTouchX = e.touches[0].clientX;
                    previousTouchY = e.touches[0].clientY;
                }
                if (e.touches.length === 2) {
                    gestureType = 'pinch_rotate';
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialDistance = Math.sqrt(dx*dx + dy*dy);
                    initialAngle = Math.atan2(dy, dx);
                    if (objects.length > 0) {
                        initialScale = objects[objects.length-1].scale.clone();
                        initialRotation = objects[objects.length-1].rotation.y;
                    }
                }
            }, { passive: false });

            el.addEventListener('touchmove', (e) => {
                // Prevent default to stop scrolling
                e.preventDefault(); 
                
                if (objects.length === 0) return;
                const targetObj = objects[objects.length - 1]; // Control last object

                if (isDragging && e.touches.length === 1 && !gestureType) {
                    // Move logic (very basic projection)
                    const deltaX = (e.touches[0].clientX - previousTouchX) * 0.005;
                    const deltaY = (e.touches[0].clientY - previousTouchY) * 0.005;
                    
                    targetObj.position.x += deltaX;
                    targetObj.position.z += deltaY; // Map Y movement to Z depth roughly
                    
                    previousTouchX = e.touches[0].clientX;
                    previousTouchY = e.touches[0].clientY;
                }

                if (gestureType === 'pinch_rotate' && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);

                    // Scale
                    const scaleRatio = distance / initialDistance;
                    targetObj.scale.copy(initialScale).multiplyScalar(scaleRatio);

                    // Rotate
                    const rotDelta = angle - initialAngle;
                    targetObj.rotation.y = initialRotation + rotDelta;
                }
            }, { passive: false });

            el.addEventListener('touchend', () => {
                isDragging = false;
                gestureType = null;
            });
        }
    </script>
</body>
</html>