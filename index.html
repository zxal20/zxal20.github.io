<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>AR Gallery Pro - Optimized Low Power</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    
    <link href="css/Vazirmatn-font-face.css" rel="stylesheet" type="text/css" />

    <script src="js/babylon.js"></script>
    <script src="js/mediapipe/selfie_segmentation.js" defer></script>

    <style>
        body { font-family: 'Vazirmatn', sans-serif; margin: 0; overflow: hidden; background-color: #000; user-select: none; -webkit-tap-highlight-color: transparent; color: white; }
        
        /* Force remove Babylon default VR/AR icon */
        .babylonVRicon { display: none !important; }

        /* UI Layer Styles */
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; transition: opacity 0.3s; }
        .ui-hidden #ui-layer { opacity: 0; pointer-events: none; }
        .ui-top-bar { padding: 15px; display: flex; justify-content: space-between; pointer-events: auto; padding-top: env(safe-area-inset-top, 20px); }
        .ui-top-bar-left, .ui-top-bar-right { display: flex; gap: 10px; }
        .ui-bottom-controls { padding: 10px 15px; background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); pointer-events: auto; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; width: 100%; box-sizing: border-box; padding-bottom: calc(20px + env(safe-area-inset-bottom, 10px)); }
        
        .btn-icon { background: rgba(40, 40, 40, 0.85); border: 1px solid rgba(255, 255, 255, 0.2); color: white; width: 42px; height: 42px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s, background 0.3s; pointer-events: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.3); padding: 0; margin: 0; }
        .btn-icon:active { transform: scale(0.9); background: rgba(255, 255, 255, 0.3); }
        .btn-icon.active-mode { background: #3b82f6; border-color: #60a5fa; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        .btn-icon.exit-mode { background: rgba(220, 38, 38, 0.8); border-color: #f87171; }
        .hidden { display: none !important; }
        
        .btn-label { background: #2563eb; color: white; padding: 8px 16px; border-radius: 30px; display: flex; align-items: center; gap: 10px; font-weight: bold; cursor: pointer; transition: transform 0.2s; pointer-events: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.3); font-size: 0.9rem; }
        .btn-label:active { transform: scale(0.95); }
        
        .controls-row { display: flex; gap: 10px; align-items: center; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 40px; flex-wrap: wrap; justify-content: center; }
        
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; border: 1px solid white; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }
        
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 200; display: none; justify-content: center; align-items: center; padding: 20px; pointer-events: auto; box-sizing: border-box; backdrop-filter: blur(5px); }
        .modal-content { background: #1f2937; color: white; padding: 25px; border-radius: 20px; max-width: 400px; width: 100%; border: 1px solid #374151; text-align: right; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #374151; padding-bottom: 10px; }
        .modal-title { font-size: 1.1rem; font-weight: bold; color: #60a5fa; margin: 0; }
        
        #temp-reveal-btn { position: fixed; top: 80px; right: 20px; z-index: 100; display: none; padding: 12px 25px; background: rgba(37, 99, 235, 0.9); color: white; font-weight: bold; font-size: 1rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        
        #touch-status { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.6); color: white; padding: 10px 20px; border-radius: 20px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 20; font-size: 0.9rem; }
        
        .radio-group { display: flex; flex-direction: column; gap: 15px; margin-top: 10px; }
        .radio-item { display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px; }
        .radio-item:hover { background: rgba(255,255,255,0.1); }
        .radio-item input { width: 20px; height: 20px; accent-color: #3b82f6; }
        
        #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; -webkit-tap-highlight-color: transparent; }
        
        #custom-ar-btn { position: absolute; bottom: 80px; right: 30px; padding: 12px 30px; border: 1px solid rgba(255,255,255,0.5); border-radius: 25px; background: rgba(0,0,0,0.7); color: white; font-family: 'Vazirmatn', sans-serif; font-size: 14px; font-weight: bold; z-index: 50; cursor: pointer; box-shadow: 0 0 15px rgba(0,0,0,0.5); transition: all 0.2s; }
        #custom-ar-btn:active { transform: scale(0.95); background: rgba(37, 99, 235, 0.8); }
        
        .w-full { width: 100%; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .gap-3 { gap: 12px; }
        .text-xs { font-size: 0.75rem; }
        .text-white { color: white; }
        .bg-black\/60 { background-color: rgba(0,0,0,0.6); }
        .rounded-full { border-radius: 9999px; }
        .p-2 { padding: 0.5rem; }
        .flex-grow { flex-grow: 1; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 0.5rem; } 
        .justify-end { justify-content: flex-end; }
        .flex-col { flex-direction: column; }
        #cube-shape-btn { width: 50px; height: 50px; }
        #cube-shape-btn svg { width: 26px; height: 26px; }
    </style>
</head>
<body id="app-body">

    <canvas id="renderCanvas"></canvas>
    
    <div id="touch-status">وضعیت</div>
    <button id="custom-ar-btn">ورود به AR </button>
    <button id="temp-reveal-btn">آشکارسازی دکمه‌ها</button>

    <div id="ui-layer">
        <div class="ui-top-bar">
            <div class="ui-top-bar-left">
                <button id="exit-btn" class="btn-icon exit-mode" title="برگشت">
                   <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M10 12.5a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v2a.5.5 0 0 0 1 0v-2A1.5 1.5 0 0 0 9.5 2h-8A1.5 1.5 0 0 0 0 3.5v9A1.5 1.5 0 0 0 1.5 14h8a1.5 1.5 0 0 0 1.5-1.5v-2a.5.5 0 0 0-1 0v2z"/><path fill-rule="evenodd" d="M15.854 8.354a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L14.293 7.5H5.5a.5.5 0 0 0 0 1h8.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3z"/></svg>
                </button>
                <button id="about-btn" class="btn-icon" title="درباره ما"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/></svg></button>
                <button id="help-btn" class="btn-icon" title="راهنما"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/></svg></button>
                <button id="settings-btn" class="btn-icon" title="تنظیمات"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/><path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1-1.255-.52l-.094-.319z"/></svg></button>
            </div>
            <div class="ui-top-bar-right">
                <button id="clean-view-btn" class="btn-icon hidden" title="پنهان شدن دکمه‌ها"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/></svg></button>
                <button id="fullscreen-btn" class="btn-icon hidden" title="تمام صفحه"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></button>
            </div>
        </div>

        <div class="ui-bottom-controls">
            <div id="dist-container" class="w-full px-8 hidden mb-2">
                <div class="flex items-center gap-3 w-full bg-black/60 p-2 rounded-full border border-gray-600">
                    <span class="text-xs text-yellow-400 font-bold whitespace-nowrap">فاصله:</span>
                    <input type="range" id="dist-slider" min="0.5" max="5.0" value="1.5" step="0.1" class="flex-grow">
                </div>
            </div>

            <div id="seek-container" class="w-full px-8 hidden mb-2">
                <div class="flex items-center gap-2 w-full bg-black/40 p-2 rounded-full">
                    <span id="current-time" class="text-xs text-white min-w-[35px] text-center">0:00</span>
                    <input type="range" id="seek-bar" min="0" value="0" step="0.1" class="flex-grow">
                    <span id="duration-time" class="text-xs text-white min-w-[35px] text-center">0:00</span>
                </div>
            </div>
            
            <div class="w-full flex justify-end px-8 mb-4">
                <label id="file-label" class="btn-label">
                    <span>انتخاب ویدیو یا عکس</span>
                    <input type="file" id="file-input" accept="video/*,image/*" style="display: none;">
                </label>
            </div>

            <div id="controls-panel" class="flex flex-col gap-3 items-center hidden w-full">
                <div class="controls-row">
                    <button id="play-btn" class="btn-icon" style="width: 50px; height: 50px; background: #2563eb; display:none;">
                         <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg>
                         <svg id="pause-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5 6.25a1.25 1.25 0 1 1 2.5 0v3.5a1.25 1.25 0 1 1-2.5 0v-3.5zm3.5 0a1.25 1.25 0 1 1 2.5 0v3.5a1.25 1.25 0 1 1-2.5 0v-3.5z"/></svg>
                    </button>
                    <button id="remove-bg-btn" class="btn-icon" title="حذف بکگراند (اشخاص)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/><path fill-rule="evenodd" d="M13.5 5a.5.5 0 0 1 .5.5V7h1.5a.5.5 0 0 1 0 1H14v1.5a.5.5 0 0 1-1 0V8h-1.5a.5.5 0 0 1 0-1H13V5.5a.5.5 0 0 1 .5-.5Z"/></svg></button>
                </div>
                <div id="size-controls" class="controls-row mt-2">
                    <button id="reset-btn" class="btn-icon" title="بازنشانی کامل"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg></button>
                    <button id="cube-shape-btn" class="btn-icon" title="تبدیل به مکعب سه بعدی"><svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M8.186 1.113a.5.5 0 0 0-.372 0L1.846 3.5l2.404.961L10.404 2l-2.218-.887zm3.564 1.426L5.596 5 8 5.961 14.154 3.5l-2.404-.961zm3.25 1.7-6.5 2.6v7.922l6.5-2.6V4.24zM7.5 14.762V6.838L1 4.239v7.923l6.5 2.6zM7.443.184a1.5 1.5 0 0 1 1.114 0l7.129 2.852A.5.5 0 0 1 16 3.5v8.662a1 1 0 0 1-.629.928l-7.185 2.874a.5.5 0 0 1-.372 0L.63 13.09a1 1 0 0 1-.63-.928V3.5a.5.5 0 0 1 .314-.464L7.443.184z"/></svg></button>
                    <button id="mode-3d-btn" class="btn-icon" title="چرخش ۳ بعدی"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/><path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/><path d="M8 1a.5.5 0 0 1 .5.5v14a.5.5 0 0 1-1 0v-14A.5.5 0 0 1 8 1z" opacity="0.5"/><path d="M1 8a.5.5 0 0 1 .5-.5h14a.5.5 0 0 1 0 1h-14A.5.5 0 0 1 1 8z" opacity="0.5"/></svg></button>
                    <button id="rotate-btn" class="btn-icon" title="چرخش 90 درجه"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/><path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/></svg></button>
                    <button id="aspect-btn" class="btn-icon" title="نسبت تصویر"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M5 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H5zm6 10H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1z"/></svg></button>
                    <button id="stretch-btn" class="btn-icon" title="تغییر سایز آزاد"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/><path fill-rule="evenodd" d="M13.5 12.5a.5.5 0 0 1 0-1l2 1.5-2 1.5a.5.5 0 0 1 0-1V12.5zM2.5 12.5V13a.5.5 0 0 1 0 1l-2-1.5 2-1.5a.5.5 0 0 1 0 1v.5z"/><path d="M2.5 3.5a.5.5 0 0 1 0 1l-2-1.5 2-1.5a.5.5 0 0 1 0 1v.5zm11 0v-.5a.5.5 0 0 1 0-1l2 1.5-2 1.5a.5.5 0 0 1 0-1v-.5z"/></svg></button>
                </div>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">تنظیمات آشکارسازی</h3>
                <button id="close-settings-btn" style="background:none; border:none; color:white; font-size:1.5rem;">&times;</button>
            </div>
            <p style="font-size: 0.9rem; color: #ccc;">نحوه نمایش دوباره دکمه‌ها را انتخاب کنید:</p>
            <div class="radio-group">
                <label class="radio-item"><input type="radio" name="reveal-mode" value="button" checked><span>نمایش دکمه موقت با لمس (۲ ثانیه)</span></label>
                <label class="radio-item"><input type="radio" name="reveal-mode" value="gesture"><span>چهار انگشت همزمان روی صفحه</span></label>
            </div>
        </div>
    </div>
    
    <div id="about-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <div class="modal-header" style="justify-content: center; position: relative;">
                <h3 class="modal-title" style="font-size: 1.3rem;">درباره ما</h3>
                <button id="close-about-btn" style="background:none; border:none; color:white; font-size:1.5rem; position: absolute; left: 0;">&times;</button>
            </div>
            <div style="padding: 20px 0;">
                <p style="font-size: 1rem;">ساخته شده توسط ابزار فوق العاده</p>
                <p style="font-size: 0.8rem; color: #aaa;">نسخه بهینه شده (Low Power)</p>
            </div>
        </div>
    </div>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">راهنمای کامل</h3>
                <button id="close-help-btn" style="background:none; border:none; color:white; font-size:1.5rem;">&times;</button>
            </div>
            <div style="max-height: 400px; overflow-y: auto;">
                <ul style="list-style-type: none; padding: 0; line-height: 1.8; font-size: 0.9rem;">
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>1. شروع کار:</strong> ابتدا با دکمه آبی فایل ویدیو یا عکس خود را انتخاب کنید.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>2. جابجایی (حرکت):</strong><br>• <span>یک انگشت:</span> جابجایی تصویر.<br>• <span>دو انگشت (حرکت همزمان):</span> جابجایی در تمام حالت‌ها.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>3. زوم و چرخش (دو انگشت):</strong><br>• <span>باز و بسته کردن:</span> زوم.<br>• <span>چرخاندن:</span> چرخش تصویر.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>4. حالت AR:</strong> در حالت AR دکمه‌ها روی صفحه باقی می‌مانند.</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Prevent default browser behaviors
        window.addEventListener("contextmenu", e => e.preventDefault());
        
        if (window.history && window.history.replaceState) {
            window.history.replaceState(null, null, window.location.href);
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(reg => console.log('SW Reg!', reg))
                    .catch(err => console.log('SW Fail', err));
            });
        }
        
        // --- UI UTILS ---
        function formatTime(seconds) { const m = Math.floor(seconds / 60); const s = Math.floor(seconds % 60); return `${m}:${s < 10 ? '0' : ''}${s}`; }
        function showToast(msg) { touchStatus.innerText = msg; touchStatus.style.opacity = '1'; setTimeout(() => { touchStatus.style.opacity = '0'; }, 2500); }
        
        function cleanSceneContent() {
            if (currentMesh) { currentMesh.dispose(); currentMesh = null; }
            if (currentVideo) { currentVideo.pause(); currentVideo.removeAttribute('src'); currentVideo.load(); currentVideo = null; }
            if (currentImageTexture) { currentImageTexture.dispose(); currentImageTexture = null; }
            if (currentVideoTexture) { currentVideoTexture.dispose(); currentVideoTexture = null; }
            if (processedTexture) { processedTexture.dispose(); processedTexture = null; }
            
            // Hide controls initially until file selected
            controlsPanel.classList.add('hidden'); controlsPanel.classList.remove('flex'); 
            cleanViewBtn.classList.add('hidden'); 
            distContainer.classList.add('hidden'); 
            seekContainer.classList.add('hidden');
            fileLabel.querySelector('span').innerText = "انتخاب ویدیو یا عکس"; 
            fileInput.value = '';
            isCubeMode = false; cubeShapeBtn.classList.remove('active-mode');
        }

        function resetAppToInitialState() { 
            // When exiting AR, we keep the content but reset view
            fullscreenBtn.style.display = 'flex'; 
            fullscreenBtn.classList.remove('hidden'); 
            // Reset Preview Camera
            if(camera && !xrHelper?.baseExperience?.state === BABYLON.WebXRState.IN_XR) {
                camera.position.set(0, 0, -2.5);
                camera.setTarget(BABYLON.Vector3.Zero());
            }
        }

        // *** BABYLON VARIABLES ***
        let engine, scene, camera, currentMesh = null, xrHelper = null;
        let currentVideo = null, currentImageTexture = null, currentVideoTexture = null;
        let isStretchMode = false, is3DMode = false, isCubeMode = false, currentOriginalWidth = 1, currentOriginalHeight = 1, aspectRatioMode = 0;
        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        let initialPinchDistance = 0, initialScale = new BABYLON.Vector3(), initialAngle = 0, initialRotationZ = 0, initialMidpoint = null;
        let initialMeshPosition = new BABYLON.Vector3(), gestureType = null;
        let uiHidden = false, revealMode = 'button', revealTimer = null;
        let selfieSegmentation = null, isBgRemovalActive = false, segmentationCanvas = document.createElement('canvas'), segmentationCtx = segmentationCanvas.getContext('2d', { willReadFrequently: true }), processedTexture = null, lastProcessTime = 0, isProcessing = false;
        
        let PROCESS_INTERVAL = 83; 
        const TARGET_RESOLUTION = 360;

        // Element References
        const uiLayer = document.getElementById('ui-layer'), fileInput = document.getElementById('file-input'), fileLabel = document.getElementById('file-label'), controlsPanel = document.getElementById('controls-panel'), cleanViewBtn = document.getElementById('clean-view-btn'), fullscreenBtn = document.getElementById('fullscreen-btn'), distContainer = document.getElementById('dist-container'), seekContainer = document.getElementById('seek-container'), playBtn = document.getElementById('play-btn'), playIcon = document.getElementById('play-icon'), pauseIcon = document.getElementById('pause-icon'), seekBar = document.getElementById('seek-bar'), currentTimeEl = document.getElementById('current-time'), durationTimeEl = document.getElementById('duration-time'), touchStatus = document.getElementById('touch-status'), distSlider = document.getElementById('dist-slider'), tempRevealBtn = document.getElementById('temp-reveal-btn'), settingsBtn = document.getElementById('settings-btn'), settingsModal = document.getElementById('settings-modal'), helpModal = document.getElementById('help-modal'), removeBgBtn = document.getElementById('remove-bg-btn'), customArBtn = document.getElementById('custom-ar-btn'), exitBtn = document.getElementById('exit-btn'), aboutBtn = document.getElementById('about-btn'), aboutModal = document.getElementById('about-modal'), cubeShapeBtn = document.getElementById('cube-shape-btn');

        function initMediaPipe() {
             if (window.SelfieSegmentation && !selfieSegmentation) {
                selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `./js/mediapipe/${file}`});
                selfieSegmentation.setOptions({ modelSelection: 0, selfieMode: false });
                selfieSegmentation.onResults(onSegmentationResults);
            }
        }

        window.addEventListener('DOMContentLoaded', init);

        async function init() {
            const canvas = document.getElementById("renderCanvas");
            // *** OPTIMIZATION: Low Power, No Stencil, No Antialias ***
            engine = new BABYLON.Engine(canvas, true, { 
                preserveDrawingBuffer: false, 
                stencil: false, 
                antialias: false,
                disableWebGL2Support: false, 
                powerPreference: 'low-power' 
            });
            
            // *** OPTIMIZATION: Hardware Scaling to 2.0 (renders at half resolution to save GPU) ***
            engine.setHardwareScalingLevel(2.0); 

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);
            
            // *** NON-AR CAMERA (PREVIEW MODE) ***
            camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, -2.5), scene);
            camera.setTarget(BABYLON.Vector3.Zero());

            // Light (Exists but material will ignore it)
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            // *** XR SETUP ***
            try {
                const xrSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync('immersive-ar');
                
                if (xrSupported) {
                    xrHelper = await scene.createDefaultXRExperienceAsync({
                        uiOptions: {
                            sessionMode: "immersive-ar",
                            referenceSpaceType: "local-floor",
                            onError: (error) => { console.log("XR Error", error); }
                        },
                        optionalFeatures: true
                    });

                    // Hide the default VR icon via code as well
                    const div = document.getElementsByClassName("babylonVRicon")[0];
                    if (div) div.style.display = "none";

                    // *** ENABLE DOM OVERLAY ***
                    const featureManager = xrHelper.baseExperience.featuresManager;
                    featureManager.enableFeature(BABYLON.WebXRFeatureName.DOM_OVERLAY, "latest", {
                        element: document.body,
                        suppressXRFocus: true
                    });

                    // State Logic
                    xrHelper.baseExperience.onStateChangedObservable.add((state) => {
                        if (state === BABYLON.WebXRState.IN_XR) {
                            customArBtn.style.display = 'none'; 
                            fullscreenBtn.style.display = 'none'; 
                            exitBtn.style.display = 'none';
                            document.body.style.backgroundColor = "transparent";
                            showToast("AR فعال شد");
                            
                            // Transfer mesh to front of camera in AR
                            if(currentMesh) {
                                const cam = xrHelper.baseExperience.camera;
                                const forward = cam.getForwardRay(1.5);
                                currentMesh.position.copyFrom(forward.origin.add(forward.direction.scale(1.5)));
                                currentMesh.lookAt(cam.position, Math.PI);
                                // Ensure rotation is upright (reset Z)
                                currentMesh.rotation.z = 0; 
                            }

                        } else if (state === BABYLON.WebXRState.NOT_IN_XR) {
                            customArBtn.style.display = 'block'; 
                            exitBtn.style.display = 'flex';
                            document.body.style.backgroundColor = "#000";
                            showToast("خروج از AR");
                            
                            // Reset mesh for Preview Mode
                            if(currentMesh) {
                                currentMesh.position.set(0, 0, 0);
                                currentMesh.rotation.set(0, Math.PI, 0); // Reset rotation standard
                                camera.position.set(0, 0, -2.5);
                                camera.setTarget(BABYLON.Vector3.Zero());
                            }
                        }
                    });
                } else {
                    console.log("WebXR not supported on this device/browser");
                    customArBtn.style.opacity = "0.5";
                }

            } catch (e) {
                console.log("WebXR Init Error", e);
            }

            // *** OPTIMIZATION: FPS LOCK TO 30 ***
            const targetFPS = 30;
            const interval = 1000 / targetFPS;
            let lastTime = performance.now();

            engine.runRenderLoop(() => {
                const now = performance.now();
                const delta = now - lastTime;

                if (delta > interval) {
                    lastTime = now - (delta % interval);
                    
                    if (isBgRemovalActive && processedTexture) {
                        processedTexture.update();
                    }
                    scene.render();
                }
            });

            // *** AR ENTER BUTTON ***
            customArBtn.addEventListener('click', async () => {
                if (!currentMesh) { showToast("لطفا ابتدا یک فایل انتخاب کنید"); return; }
                
                if (xrHelper && xrHelper.baseExperience) {
                   try {
                       await xrHelper.baseExperience.enterXRAsync("immersive-ar", "local-floor");
                   } catch(e) {
                       showToast("خطا در اجرای AR");
                       console.error(e);
                   }
                } else {
                    showToast("مرورگر شما AR پشتیبانی نمی‌کند");
                }
            });

            window.addEventListener('resize', () => engine.resize());
            setupUIListeners(); 
            setupTouchGestures();
        }

        function setupUIListeners() {
            exitBtn.addEventListener('click', () => { window.history.back(); });
            aboutBtn.addEventListener('click', () => aboutModal.style.display = 'flex'); document.getElementById('close-about-btn').addEventListener('click', () => aboutModal.style.display = 'none');
            fileInput.addEventListener('click', (e) => { e.stopPropagation(); cleanSceneContent(); });
            fileInput.addEventListener('change', handleFileSelect);
            cleanViewBtn.addEventListener('click', () => { uiHidden = true; document.body.classList.add('ui-hidden'); showToast("منوها پنهان شدند"); });
            tempRevealBtn.addEventListener('click', () => revealUI());
            settingsBtn.addEventListener('click', () => settingsModal.style.display = 'flex'); document.getElementById('close-settings-btn').addEventListener('click', () => settingsModal.style.display = 'none');
            document.querySelectorAll('input[name="reveal-mode"]').forEach(radio => radio.addEventListener('change', (e) => revealMode = e.target.value));
            document.getElementById('help-btn').addEventListener('click', () => helpModal.style.display = 'flex'); document.getElementById('close-help-btn').addEventListener('click', () => helpModal.style.display = 'none');
            fullscreenBtn.addEventListener('click', () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); });
            
            playBtn.addEventListener('click', () => { 
                if (currentVideo) { 
                    if (currentVideo.paused) { currentVideo.play(); playIcon.classList.add('hidden'); pauseIcon.classList.remove('hidden'); } 
                    else { currentVideo.pause(); playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden'); } 
                } 
            });
            
            seekBar.addEventListener('input', () => { if (currentVideo) currentVideo.currentTime = seekBar.value; });
            
            distSlider.addEventListener('input', (e) => { 
                if (currentMesh) {
                     // Simple implementation
                } 
            }); 
            
            // *** FIXED RESET BUTTON: Snaps to view ***
            document.getElementById('reset-btn').addEventListener('click', () => { 
                if (currentMesh) { 
                    distSlider.value = 1.5; 
                    
                    if (xrHelper && xrHelper.baseExperience && xrHelper.baseExperience.state === BABYLON.WebXRState.IN_XR) {
                        // AR Mode: Snap to front of camera
                        const cam = xrHelper.baseExperience.camera;
                        const forward = cam.getForwardRay(1.5);
                        currentMesh.position.copyFrom(forward.origin.add(forward.direction.scale(1.5)));
                        currentMesh.lookAt(cam.position, Math.PI);
                        currentMesh.rotation.z = 0; // Force upright
                    } else {
                        // Preview Mode: Reset to origin
                        currentMesh.position.set(0, 0, 0); 
                        currentMesh.rotation.set(0, Math.PI, 0); 
                    }
                    
                    initialRotationZ = 0; 
                    currentMesh.scaling.set(1, 1, 1); 
                    isStretchMode = false; is3DMode = false; 
                    document.getElementById('stretch-btn').classList.remove('active-mode'); 
                    document.getElementById('mode-3d-btn').classList.remove('active-mode'); 
                    showToast("بازنشانی موقعیت"); 
                } 
            });

            cubeShapeBtn.addEventListener('click', () => { 
                if (!currentMesh) return; 
                isCubeMode = !isCubeMode; 
                cubeShapeBtn.classList.toggle('active-mode', isCubeMode); 
                rebuildMeshGeometry();
                showToast(isCubeMode ? "حالت مکعب" : "حالت تخت");
            });

            document.getElementById('mode-3d-btn').addEventListener('click', function() { is3DMode = !is3DMode; this.classList.toggle('active-mode', is3DMode); showToast(is3DMode ? "چرخش ۳ بعدی" : "حالت جابجایی"); });
            document.getElementById('rotate-btn').addEventListener('click', () => { if (currentMesh) currentMesh.rotation.z -= Math.PI / 2; });
            document.getElementById('aspect-btn').addEventListener('click', () => { 
                if (!currentMesh) return; 
                aspectRatioMode = (aspectRatioMode + 1) % 4; 
                const modes = ["سایز اصلی", "عریض", "مرتفع", "بزرگ"]; 
                currentMesh.scaling.set(aspectRatioMode===3?2:aspectRatioMode===1?1.5:1, aspectRatioMode===3?2:aspectRatioMode===2?1.5:1, 1); 
                showToast(modes[aspectRatioMode]); 
            });
            document.getElementById('stretch-btn').addEventListener('click', function() { isStretchMode = !isStretchMode; this.classList.toggle('active-mode', isStretchMode); showToast(isStretchMode ? "تغییر سایز آزاد" : "تغییر سایز قفل"); });
            removeBgBtn.addEventListener('click', toggleBgRemoval);
        }

        async function toggleBgRemoval() {
            if (!currentMesh) return;
            if (!selfieSegmentation) { 
                showToast("در حال راه‌اندازی هوش مصنوعی...");
                initMediaPipe(); 
                setTimeout(toggleBgRemoval, 1000);
                return;
            }
            
            isBgRemovalActive = !isBgRemovalActive; removeBgBtn.classList.toggle('active-mode', isBgRemovalActive);
            
            const mat = currentMesh.material;
            if (isBgRemovalActive) {
                showToast("حذف پس‌زمینه");
                let w = currentVideo ? currentVideo.videoWidth : currentImageTexture.getSize().width;
                let h = currentVideo ? currentVideo.videoHeight : currentImageTexture.getSize().height;
                
                let scaleFactor = 1; if (w > TARGET_RESOLUTION) { scaleFactor = TARGET_RESOLUTION / w; w = TARGET_RESOLUTION; h = Math.floor(h * scaleFactor); }
                segmentationCanvas.width = w; segmentationCanvas.height = h;
                
                processedTexture = new BABYLON.DynamicTexture("dynamicTex", segmentationCanvas, scene);
                processedTexture.hasAlpha = true;
                
                mat.emissiveTexture = processedTexture;
                mat.diffuseTexture = processedTexture;
                mat.useAlphaFromDiffuseTexture = true;
                
                if (currentVideo) processVideoFrame(); else if (currentImageTexture) {
                   const img = new Image();
                   img.src = currentImageTexture.url;
                   img.onload = async () => { await selfieSegmentation.send({image: img}); };
                }
            } else { 
                showToast("حذف پس‌زمینه خاموش");
                if (currentVideo) {
                    mat.emissiveTexture = currentVideoTexture;
                    mat.diffuseTexture = currentVideoTexture;
                } else {
                    mat.emissiveTexture = currentImageTexture;
                    mat.diffuseTexture = currentImageTexture;
                }
                mat.useAlphaFromDiffuseTexture = false;
                if (processedTexture) { processedTexture.dispose(); processedTexture = null; } 
            }
        }

        function onSegmentationResults(results) { 
            if (!isBgRemovalActive) { isProcessing = false; return; } 
            segmentationCtx.save(); 
            segmentationCtx.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height); 
            segmentationCtx.drawImage(results.segmentationMask, 0, 0, segmentationCanvas.width, segmentationCanvas.height); 
            segmentationCtx.globalCompositeOperation = 'source-in'; 
            segmentationCtx.drawImage(results.image, 0, 0, segmentationCanvas.width, segmentationCanvas.height); 
            segmentationCtx.restore(); 
            isProcessing = false; 
        }
        
        async function processVideoFrame() {
            if (!(isBgRemovalActive && currentVideo && !currentVideo.paused && !currentVideo.ended)) return;
            const now = performance.now();
            if (!isProcessing && (now - lastProcessTime > PROCESS_INTERVAL)) {
                isProcessing = true; lastProcessTime = now;
                try { await selfieSegmentation.send({image: currentVideo}); } catch(e) { isProcessing = false; }
            }
            requestAnimationFrame(processVideoFrame);
        }

        function revealUI() { uiHidden = false; document.body.classList.remove('ui-hidden'); tempRevealBtn.style.display = 'none'; }
        
        function handleFileSelect(event) {
            const file = event.target.files[0]; if (!file) return; cleanSceneContent(); const url = URL.createObjectURL(file); const fileType = file.type.split('/')[0];
            
            // Show UI Logic
            isBgRemovalActive = false; removeBgBtn.classList.remove('active-mode'); 
            controlsPanel.classList.remove('hidden'); controlsPanel.classList.add('flex');
            document.getElementById('size-controls').classList.remove('hidden'); 
            document.getElementById('size-controls').style.display = 'flex';
            cleanViewBtn.classList.remove('hidden'); 
            fullscreenBtn.classList.remove('hidden'); 
            distContainer.classList.remove('hidden'); 
            fileLabel.querySelector('span').innerText = "تغییر فایل";
            
            if (fileType === 'image') { processImage(url); playBtn.style.display = 'none'; seekContainer.classList.add('hidden'); } 
            else if (fileType === 'video') { processVideo(url); playBtn.style.display = 'flex'; seekContainer.classList.remove('hidden'); playIcon.classList.add('hidden'); pauseIcon.classList.remove('hidden'); }
            event.target.value = '';
        }

        function processImage(url) {
            currentImageTexture = new BABYLON.Texture(url, scene);
            currentImageTexture.onLoadObservable.add(() => {
                 createMesh(currentImageTexture, currentImageTexture.getSize().width, currentImageTexture.getSize().height);
            });
        }

        function processVideo(url) {
            const video = document.createElement('video'); 
            video.src = url; video.crossOrigin = 'anonymous'; video.loop = true; video.playsInline = true; video.muted = false; 
            currentVideo = video;
            
            video.addEventListener('loadedmetadata', () => {
                seekBar.max = video.duration; durationTimeEl.innerText = formatTime(video.duration);
                currentVideoTexture = new BABYLON.VideoTexture("video", video, scene, true, false);
                createMesh(currentVideoTexture, video.videoWidth, video.videoHeight);
            });
            video.addEventListener('timeupdate', () => { seekBar.value = video.currentTime; currentTimeEl.innerText = formatTime(video.currentTime); });
            video.addEventListener('play', () => { if(isBgRemovalActive) processVideoFrame(); });
        }

        function createMesh(texture, width, height) {
            if(currentMesh) currentMesh.dispose();
            
            const aspectRatio = width / height; 
            const displayHeight = 1.0; 
            const displayWidth = displayHeight * aspectRatio; 
            currentOriginalWidth = displayWidth; 
            currentOriginalHeight = displayHeight;
            
            buildGeometry(displayWidth, displayHeight, texture);
            showToast("فایل بارگذاری شد");
        }

        function rebuildMeshGeometry() {
             const tex = isBgRemovalActive ? processedTexture : (currentVideo ? currentVideoTexture : currentImageTexture);
             const oldPos = currentMesh.position.clone();
             const oldRot = currentMesh.rotation.clone();
             const oldScale = currentMesh.scaling.clone();
             
             currentMesh.dispose();
             buildGeometry(currentOriginalWidth, currentOriginalHeight, tex);
             
             currentMesh.position = oldPos;
             currentMesh.rotation = oldRot;
             currentMesh.scaling = oldScale;
        }

        function buildGeometry(w, h, texture) {
            const mat = new BABYLON.StandardMaterial("mat", scene);
            mat.diffuseTexture = texture;
            mat.emissiveTexture = texture; 
            // *** OPTIMIZATION: Disable Lighting Calculations ***
            mat.disableLighting = true; 
            mat.backFaceCulling = false;

            if (isCubeMode) {
                 currentMesh = BABYLON.MeshBuilder.CreateBox("box", { width: w*0.5, height: h*0.5, depth: h*0.3 }, scene);
            } else {
                 currentMesh = BABYLON.MeshBuilder.CreatePlane("plane", { width: w, height: h }, scene);
            }
            
            currentMesh.material = mat;
            // *** FIX: Orientation Corrected (Removed Math.PI on Z) ***
            currentMesh.rotation.z = 0; 
            currentMesh.rotation.y = Math.PI; // Face camera standard
            
            // Initial Position for Preview (Center)
            currentMesh.position.set(0, 0, 0);
        }

        // *** GESTURE LOGIC (Adapted for Babylon) ***
        function setupTouchGestures() {
            const el = window; 
            
            el.addEventListener('touchstart', (e) => {
                if (e.target.closest('button') || e.target.closest('input')) return;

                if (!currentMesh) return;
                
                if (uiHidden) { 
                    if (revealMode === 'gesture' && e.touches.length === 4) revealUI(); 
                    else if (revealMode === 'button') { 
                        tempRevealBtn.style.display = 'block'; 
                        if (revealTimer) clearTimeout(revealTimer); 
                        revealTimer = setTimeout(() => { tempRevealBtn.style.display = 'none'; }, 2000); 
                    } 
                }
                
                if (e.touches.length === 1) { 
                    isDragging = true; 
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
                } 
                else if (e.touches.length === 2 && currentMesh) { 
                    gestureType = null; 
                    const dx = e.touches[0].clientX - e.touches[1].clientX; 
                    const dy = e.touches[0].clientY - e.touches[1].clientY; 
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy); 
                    initialScale.copyFrom(currentMesh.scaling); 
                    initialAngle = Math.atan2(dy, dx); 
                    initialRotationZ = currentMesh.rotation.z; 
                    initialMidpoint = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 }; 
                    initialMeshPosition.copyFrom(currentMesh.position); 
                }
            }, { passive: false });

            el.addEventListener('touchmove', (e) => {
                if (!currentMesh) return;
                if (e.target.closest('.ui-bottom-controls')) return;

                if (e.touches.length === 1 && isDragging) { 
                    const deltaX = e.touches[0].clientX - previousMousePosition.x; 
                    const deltaY = e.touches[0].clientY - previousMousePosition.y; 
                    
                    if (is3DMode) { 
                        currentMesh.rotation.y += deltaX * 0.005; 
                        currentMesh.rotation.x += deltaY * 0.005; 
                    } else { 
                        const sensitivity = 0.003;
                        currentMesh.position.x += deltaX * sensitivity; 
                        currentMesh.position.y -= deltaY * sensitivity; 
                    } 
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
                    return; 
                }

                if (e.touches.length === 2 && currentMesh) {
                    e.preventDefault(); 
                    
                    const dx = e.touches[0].clientX - e.touches[1].clientX; 
                    const dy = e.touches[0].clientY - e.touches[1].clientY; 
                    const distance = Math.sqrt(dx * dx + dy * dy); 
                    const angle = Math.atan2(dy, dx); 
                    const currentMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2; 
                    const currentMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2; 
                    
                    const scaleChange = Math.abs(distance - initialPinchDistance); 
                    const angleChange = Math.abs(angle - initialAngle); 
                    const panChange = Math.sqrt(Math.pow(currentMidX - initialMidpoint.x, 2) + Math.pow(currentMidY - initialMidpoint.y, 2));
                    
                    if (!gestureType) { if (panChange > 15) gestureType = 'pan'; else if (scaleChange > 15) gestureType = 'zoom'; else if (angleChange > 0.1) gestureType = 'rotate'; }
                    
                    if (gestureType === 'pan') { 
                        currentMesh.position.x = initialMeshPosition.x + (currentMidX - initialMidpoint.x) * 0.003; 
                        currentMesh.position.y = initialMeshPosition.y - (currentMidY - initialMidpoint.y) * 0.003; 
                    }
                    if (gestureType === 'zoom') { 
                        const scaleRatio = distance / initialPinchDistance; 
                        if (isStretchMode) { 
                             if (Math.abs(dx) > Math.abs(dy)) currentMesh.scaling.x = initialScale.x * scaleRatio; 
                             else currentMesh.scaling.y = initialScale.y * scaleRatio; 
                        } else { 
                            currentMesh.scaling.set(initialScale.x * scaleRatio, initialScale.y * scaleRatio, initialScale.z * scaleRatio); 
                        } 
                    }
                    if (!is3DMode && (gestureType === 'rotate')) { 
                        currentMesh.rotation.z = initialRotationZ + (angle - initialAngle); 
                    }
                }
            }, { passive: false });

            el.addEventListener('touchend', () => { isDragging = false; gestureType = null; });
        }
    </script>
</body>
</html>