<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>AR Gallery Pro - Optimized for Mobile</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    
    <link href="css/Vazirmatn-font-face.css" rel="stylesheet" type="text/css" />

    <script src="js/mediapipe/selfie_segmentation.js" defer></script>
    <script>
if (!('xr' in navigator)) {
  const s = document.createElement('script');
  s.src = 'js/webxr-polyfill.js';
  s.defer = true;
  document.head.appendChild(s);
}
</script> 
    <style>
        body { font-family: 'Vazirmatn', sans-serif; margin: 0; overflow: hidden; background-color: #000; user-select: none; -webkit-tap-highlight-color: transparent; color: white; }
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; transition: opacity 0.3s; }
        .ui-hidden #ui-layer { opacity: 0; pointer-events: none; }
        .ui-top-bar { padding: 15px; display: flex; justify-content: space-between; pointer-events: auto; padding-top: env(safe-area-inset-top, 20px); }
        .ui-top-bar-left, .ui-top-bar-right { display: flex; gap: 10px; }
        .ui-bottom-controls { padding: 10px 15px; background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); pointer-events: auto; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; width: 100%; box-sizing: border-box; padding-bottom: calc(20px + env(safe-area-inset-bottom, 10px)); }
        .btn-icon { background: rgba(40, 40, 40, 0.85); border: 1px solid rgba(255, 255, 255, 0.2); color: white; width: 42px; height: 42px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: transform 0.2s, background 0.3s; pointer-events: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.3); padding: 0; margin: 0; }
        .btn-icon:active { transform: scale(0.9); background: rgba(255, 255, 255, 0.3); }
        .btn-icon.active-mode { background: #3b82f6; border-color: #60a5fa; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        .btn-icon.exit-mode { background: rgba(220, 38, 38, 0.8); border-color: #f87171; }
        .hidden { display: none !important; }
        .btn-label { background: #2563eb; color: white; padding: 8px 16px; border-radius: 30px; display: flex; align-items: center; gap: 10px; font-weight: bold; cursor: pointer; transition: transform 0.2s; pointer-events: auto; box-shadow: 0 4px 6px rgba(0,0,0,0.3); font-size: 0.9rem; }
        .btn-label:active { transform: scale(0.95); }
        .controls-row { display: flex; gap: 10px; align-items: center; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 40px; flex-wrap: wrap; justify-content: center; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; border: 1px solid white; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 200; display: none; justify-content: center; align-items: center; padding: 20px; pointer-events: auto; box-sizing: border-box; backdrop-filter: blur(5px); }
        .modal-content { background: #1f2937; color: white; padding: 25px; border-radius: 20px; max-width: 400px; width: 100%; border: 1px solid #374151; text-align: right; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #374151; padding-bottom: 10px; }
        .modal-title { font-size: 1.1rem; font-weight: bold; color: #60a5fa; margin: 0; }
        #temp-reveal-btn { position: fixed; top: 80px; right: 20px; z-index: 100; display: none; padding: 12px 25px; background: rgba(37, 99, 235, 0.9); color: white; font-weight: bold; font-size: 1rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        #touch-status { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.6); color: white; padding: 10px 20px; border-radius: 20px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 20; font-size: 0.9rem; }
        .radio-group { display: flex; flex-direction: column; gap: 15px; margin-top: 10px; }
        .radio-item { display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 10px; }
        .radio-item:hover { background: rgba(255,255,255,0.1); }
        .radio-item input { width: 20px; height: 20px; accent-color: #3b82f6; }
        #ar-container { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; }
        #custom-ar-btn { position: absolute; bottom: 80px; right: 30px; padding: 12px 30px; border: 1px solid rgba(255,255,255,0.5); border-radius: 25px; background: rgba(0,0,0,0.7); color: white; font-family: 'Vazirmatn', sans-serif; font-size: 14px; font-weight: bold; z-index: 50; cursor: pointer; box-shadow: 0 0 15px rgba(0,0,0,0.5); transition: all 0.2s; }
        #custom-ar-btn:active { transform: scale(0.95); background: rgba(37, 99, 235, 0.8); }
        .w-full { width: 100%; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .gap-3 { gap: 12px; }
        .text-xs { font-size: 0.75rem; }
        .text-white { color: white; }
        .bg-black\/60 { background-color: rgba(0,0,0,0.6); }
        .rounded-full { border-radius: 9999px; }
        .p-2 { padding: 0.5rem; }
        .flex-grow { flex-grow: 1; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 0.5rem; } 
        .justify-end { justify-content: flex-end; }
        .flex-col { flex-direction: column; }
        #cube-shape-btn { width: 50px; height: 50px; }
        #cube-shape-btn svg { width: 26px; height: 26px; }
    </style>
</head>
<body id="app-body">

    <div id="ar-container"></div>
    <div id="touch-status">وضعیت</div>
    <button id="custom-ar-btn">ورود به AR </button>
    <button id="temp-reveal-btn">آشکارسازی دکمه‌ها</button>

    <div id="ui-layer">
        <div class="ui-top-bar">
            <div class="ui-top-bar-left">
                <button id="exit-btn" class="btn-icon exit-mode" title="برگشت">
                   <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M10 12.5a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v2a.5.5 0 0 0 1 0v-2A1.5 1.5 0 0 0 9.5 2h-8A1.5 1.5 0 0 0 0 3.5v9A1.5 1.5 0 0 0 1.5 14h8a1.5 1.5 0 0 0 1.5-1.5v-2a.5.5 0 0 0-1 0v2z"/><path fill-rule="evenodd" d="M15.854 8.354a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L14.293 7.5H5.5a.5.5 0 0 0 0 1h8.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3z"/></svg>
                </button>
                <button id="about-btn" class="btn-icon" title="درباره ما"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/></svg></button>
                <button id="help-btn" class="btn-icon" title="راهنما"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/></svg></button>
                <button id="settings-btn" class="btn-icon" title="تنظیمات"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/><path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1-1.255-.52l-.094-.319z"/></svg></button>
            </div>
            <div class="ui-top-bar-right">
                <button id="clean-view-btn" class="btn-icon hidden" title="پنهان شدن دکمه‌ها"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/><path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/></svg></button>
                <button id="fullscreen-btn" class="btn-icon hidden" title="تمام صفحه"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg></button>
            </div>
        </div>

        <div class="ui-bottom-controls">
            <div id="dist-container" class="w-full px-8 hidden mb-2">
                <div class="flex items-center gap-3 w-full bg-black/60 p-2 rounded-full border border-gray-600">
                    <span class="text-xs text-yellow-400 font-bold whitespace-nowrap">فاصله:</span>
                    <input type="range" id="dist-slider" min="0.5" max="5.0" value="1.0" step="0.1" class="flex-grow">
                </div>
            </div>

            <div id="seek-container" class="w-full px-8 hidden mb-2">
                <div class="flex items-center gap-2 w-full bg-black/40 p-2 rounded-full">
                    <span id="current-time" class="text-xs text-white min-w-[35px] text-center">0:00</span>
                    <input type="range" id="seek-bar" min="0" value="0" step="0.1" class="flex-grow">
                    <span id="duration-time" class="text-xs text-white min-w-[35px] text-center">0:00</span>
                </div>
            </div>
            
            <div class="w-full flex justify-end px-8 mb-4">
                <label id="file-label" class="btn-label">
                    <span>انتخاب ویدیو یا عکس</span>
                    <input type="file" id="file-input" accept="video/*,image/*" style="display: none;">
                </label>
            </div>

            <div id="controls-panel" class="flex flex-col gap-3 items-center hidden w-full">
                <div class="controls-row">
                    <button id="play-btn" class="btn-icon" style="width: 50px; height: 50px; background: #2563eb; display:none;">
                         <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg>
                         <svg id="pause-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M5 6.25a1.25 1.25 0 1 1 2.5 0v3.5a1.25 1.25 0 1 1-2.5 0v-3.5zm3.5 0a1.25 1.25 0 1 1 2.5 0v3.5a1.25 1.25 0 1 1-2.5 0v-3.5z"/></svg>
                    </button>
                    <button id="remove-bg-btn" class="btn-icon" title="حذف بکگراند (اشخاص)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3Zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/><path fill-rule="evenodd" d="M13.5 5a.5.5 0 0 1 .5.5V7h1.5a.5.5 0 0 1 0 1H14v1.5a.5.5 0 0 1-1 0V8h-1.5a.5.5 0 0 1 0-1H13V5.5a.5.5 0 0 1 .5-.5Z"/></svg></button>
                </div>
                <div id="size-controls" class="controls-row mt-2">
                    <button id="reset-btn" class="btn-icon" title="بازنشانی کامل"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg></button>
                    <button id="cube-shape-btn" class="btn-icon" title="تبدیل به مکعب سه بعدی"><svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M8.186 1.113a.5.5 0 0 0-.372 0L1.846 3.5l2.404.961L10.404 2l-2.218-.887zm3.564 1.426L5.596 5 8 5.961 14.154 3.5l-2.404-.961zm3.25 1.7-6.5 2.6v7.922l6.5-2.6V4.24zM7.5 14.762V6.838L1 4.239v7.923l6.5 2.6zM7.443.184a1.5 1.5 0 0 1 1.114 0l7.129 2.852A.5.5 0 0 1 16 3.5v8.662a1 1 0 0 1-.629.928l-7.185 2.874a.5.5 0 0 1-.372 0L.63 13.09a1 1 0 0 1-.63-.928V3.5a.5.5 0 0 1 .314-.464L7.443.184z"/></svg></button>
                    <button id="mode-3d-btn" class="btn-icon" title="چرخش ۳ بعدی"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/><path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/><path d="M8 1a.5.5 0 0 1 .5.5v14a.5.5 0 0 1-1 0v-14A.5.5 0 0 1 8 1z" opacity="0.5"/><path d="M1 8a.5.5 0 0 1 .5-.5h14a.5.5 0 0 1 0 1h-14A.5.5 0 0 1 1 8z" opacity="0.5"/></svg></button>
                    <button id="rotate-btn" class="btn-icon" title="چرخش 90 درجه"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/><path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/></svg></button>
                    <button id="aspect-btn" class="btn-icon" title="نسبت تصویر"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M5 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H5zm6 10H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1z"/></svg></button>
                    <button id="stretch-btn" class="btn-icon" title="تغییر سایز آزاد"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/><path fill-rule="evenodd" d="M13.5 12.5a.5.5 0 0 1 0-1l2 1.5-2 1.5a.5.5 0 0 1 0-1V12.5zM2.5 12.5V13a.5.5 0 0 1 0 1l-2-1.5 2-1.5a.5.5 0 0 1 0 1v.5z"/><path d="M2.5 3.5a.5.5 0 0 1 0 1l-2-1.5 2-1.5a.5.5 0 0 1 0 1v.5zm11 0v-.5a.5.5 0 0 1 0-1l2 1.5-2 1.5a.5.5 0 0 1 0-1v-.5z"/></svg></button>
                </div>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">تنظیمات آشکارسازی</h3>
                <button id="close-settings-btn" style="background:none; border:none; color:white; font-size:1.5rem;">&times;</button>
            </div>
            <p style="font-size: 0.9rem; color: #ccc;">نحوه نمایش دوباره دکمه‌ها را انتخاب کنید:</p>
            <div class="radio-group">
                <label class="radio-item"><input type="radio" name="reveal-mode" value="button" checked><span>نمایش دکمه موقت با لمس (۲ ثانیه)</span></label>
                <label class="radio-item"><input type="radio" name="reveal-mode" value="gesture"><span>چهار انگشت همزمان روی صفحه</span></label>
            </div>
        </div>
    </div>
    
    <div id="about-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <div class="modal-header" style="justify-content: center; position: relative;">
                <h3 class="modal-title" style="font-size: 1.3rem;">درباره ما</h3>
                <button id="close-about-btn" style="background:none; border:none; color:white; font-size:1.5rem; position: absolute; left: 0;">&times;</button>
            </div>
            <div style="padding: 20px 0;">
                <p style="font-size: 1rem;">ساخته شده توسط ابزار فوق العاده</p>
            </div>
        </div>
    </div>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">راهنمای کامل</h3>
                <button id="close-help-btn" style="background:none; border:none; color:white; font-size:1.5rem;">&times;</button>
            </div>
            <div style="max-height: 400px; overflow-y: auto;">
                <ul style="list-style-type: none; padding: 0; line-height: 1.8; font-size: 0.9rem;">
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>1. شروع کار:</strong> ابتدا با دکمه آبی فایل ویدیو یا عکس خود را انتخاب کنید. برای کارکرد صحیح برنامه مرورگر کروم خود را به آخرین نسخه بروزرسانی کنید و برای بار اول برای دکمه حذف پس زمینه به اینترنت متصل باشید در دفعه های بعد برنامه و این قابلیت نیاز به اینترنت ندارد.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>2. جابجایی (حرکت):</strong><br>• <span>یک انگشت:</span> جابجایی تصویر.<br>• <span>دو انگشت (حرکت همزمان):</span> جابجایی در تمام حالت‌ها.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>3. زوم و چرخش (دو انگشت):</strong><br>• <span>باز و بسته کردن:</span> زوم.<br>• <span>چرخاندن:</span> چرخش تصویر.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>4. آشکارسازی دکمه‌ها:</strong> از دکمه تنظیمات آشکار سازی دکمه ها میتوانید تعیین کنید که بعد پنهان سازی دکمه ها چگونه دوباره دکمه ها آشکار شوند برای عکس از صفحه گرفتن گزینه لمس چهار انگشت همزمان پیشنهاد می شود چون با کشیدن روی صفحه سه لمس انگشت همزمان عکس از صفحه گرفته می شود و با قراردادن چهار انگشت روی صفحه دکمه ها آشکار می شوند.</li>
                    <li style="margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 8px;"><strong>5. نکته مهم:</strong> این برنامه برای موبایل بهینه سازی شده ست چون این برنامه با خود دوربین موبایل کار میکند برای خنک نگه داشتن موبایل استفاده طولانی مدت آن در حالت ar باید بیست دقیقه باشد بنابراین بعد از آن روی تغییر فایل بزنید بعد از خنک شدن دوباره موبایل وارد آن شوید.</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from './js/three.module.js';

        // پاک کردن تاریخچه برای جلوگیری از نمایش آدرس در اولین ورود
        if (window.history && window.history.replaceState) {
            window.history.replaceState(null, null, window.location.href);
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(reg => console.log('SW Reg!', reg))
                    .catch(err => console.log('SW Fail', err));
            });
        }
        
        function hideNonARUI(){ try{ if(renderer && renderer.domElement){ renderer.domElement.style.opacity="0"; renderer.domElement.style.pointerEvents="none"; } if(currentVideo) currentVideo.style.display="none"; }catch(e){} }
        function showNonARUI(){ try{ const ui=document.getElementById("ui-layer"); if(ui) ui.style.display="flex"; if(renderer && renderer.domElement){ renderer.domElement.style.opacity="1"; renderer.domElement.style.pointerEvents="auto"; } if(currentVideo) currentVideo.style.display="block"; }catch(e){} }
        function formatTime(seconds) { const m = Math.floor(seconds / 60); const s = Math.floor(seconds % 60); return `${m}:${s < 10 ? '0' : ''}${s}`; }
        function showToast(msg) { touchStatus.innerText = msg; touchStatus.style.opacity = '1'; setTimeout(() => { touchStatus.style.opacity = '0'; }, 2500); }
        function cleanSceneContent() {
            if (currentMesh) { scene.remove(currentMesh); if (currentMesh.geometry) currentMesh.geometry.dispose(); if (currentMesh.material) { if (currentMesh.material.map) currentMesh.material.map.dispose(); currentMesh.material.dispose(); } currentMesh = null; }
            if (currentVideo) { currentVideo.pause(); currentVideo.removeAttribute('src'); currentVideo.load(); currentVideo = null; }
            if (currentImageTexture) { currentImageTexture.dispose(); currentImageTexture = null; }
            if (processedTexture) { processedTexture.dispose(); processedTexture = null; }
            originalTexture = null;
            controlsPanel.classList.add('hidden'); controlsPanel.classList.remove('flex'); cleanViewBtn.classList.add('hidden'); distContainer.classList.add('hidden'); seekContainer.classList.add('hidden');
            fileLabel.querySelector('span').innerText = "انتخاب ویدیو یا عکس"; fileInput.value = '';
            isCubeMode = false; cubeShapeBtn.classList.remove('active-mode');
        }
        function removeContentMeshes() { try { const toRemove = []; scene.traverse(child => { if (child && child.isMesh && child.name === 'contentMesh') { toRemove.push(child); } }); toRemove.forEach(obj => { scene.remove(obj); if(obj.geometry) obj.geometry.dispose(); if(obj.material) obj.material.dispose(); }); if (currentMesh && toRemove.indexOf(currentMesh) !== -1) currentMesh = null; } catch(e) {} }
        function resetAppToInitialState() { cleanSceneContent(); fullscreenBtn.style.display = 'flex'; fullscreenBtn.classList.add('hidden'); isBgRemovalActive = false; removeBgBtn.classList.remove('active-mode'); distSlider.value = 1.0; }

        let camera, scene, renderer, currentMesh = null, currentVideo = null, currentImageTexture = null, currentSession = null;
        let isStretchMode = false, is3DMode = false, isCubeMode = false, currentOriginalWidth = 1, currentOriginalHeight = 1, aspectRatioMode = 0;
        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        let initialPinchDistance = 0, initialScale = new THREE.Vector3(), initialAngle = 0, initialRotationZ = 0, initialMidpoint = null, initialRotationX = 0, initialRotationY = 0, initialMeshPosition = new THREE.Vector3(), gestureType = null;
        let uiHidden = false, preventAutoPositionInAR = true, revealMode = 'button', revealTimer = null;
        let selfieSegmentation = null, isBgRemovalActive = false, segmentationCanvas = document.createElement('canvas'), segmentationCtx = segmentationCanvas.getContext('2d', { willReadFrequently: false }), originalTexture = null, processedTexture = null, lastProcessTime = 0, isProcessing = false;
        
        // --- SUPER OPTIMIZATION CONFIGURATION ---
        const PROCESS_INTERVAL = 83; 
        const TARGET_RESOLUTION = 360;

        const uiLayer = document.getElementById('ui-layer'), fileInput = document.getElementById('file-input'), fileLabel = document.getElementById('file-label'), controlsPanel = document.getElementById('controls-panel'), cleanViewBtn = document.getElementById('clean-view-btn'), fullscreenBtn = document.getElementById('fullscreen-btn'), distContainer = document.getElementById('dist-container'), seekContainer = document.getElementById('seek-container'), playBtn = document.getElementById('play-btn'), playIcon = document.getElementById('play-icon'), pauseIcon = document.getElementById('pause-icon'), seekBar = document.getElementById('seek-bar'), currentTimeEl = document.getElementById('current-time'), durationTimeEl = document.getElementById('duration-time'), touchStatus = document.getElementById('touch-status'), distSlider = document.getElementById('dist-slider'), tempRevealBtn = document.getElementById('temp-reveal-btn'), settingsBtn = document.getElementById('settings-btn'), settingsModal = document.getElementById('settings-modal'), helpModal = document.getElementById('help-modal'), removeBgBtn = document.getElementById('remove-bg-btn'), customArBtn = document.getElementById('custom-ar-btn'), exitBtn = document.getElementById('exit-btn'), aboutBtn = document.getElementById('about-btn'), aboutModal = document.getElementById('about-modal'), cubeShapeBtn = document.getElementById('cube-shape-btn');

        init();
        initMediaPipe();

        function init() {
            const container = document.getElementById('ar-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1); light.position.set(0.5, 1, 0.25); scene.add(light);
            
            // OPTIMIZATION: 'powerPreference: "low-power"' requests the GPU to run cooler
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                alpha: true, 
                preserveDrawingBuffer: false, 
                powerPreference: "low-power", 
                precision: "mediump", 
                depth: true, 
                stencil: false 
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); // Force 1x pixel ratio max
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            renderer.xr.enabled = true; 
            renderer.xr.setReferenceSpaceType('local');
            container.appendChild(renderer.domElement);
            renderer.setAnimationLoop(render);

            if (!navigator.xr) { console.log("WebXR missing"); }

            customArBtn.addEventListener('click', async () => {
                if (currentSession === null) {
                    const sessionInit = { requiredFeatures: ['local'], optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } };
                    try {
                        const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
                        renderer.xr.setSession(session); 
                        currentSession = session; 
                        
                        // *** KILLER OPTIMIZATION for GPU 25% Usage ***
                        
                        // 1. Force low Frame Rate (30 FPS) if supported
                        // This drastically cuts GPU usage by half compared to 60fps
                        if (session.supportedFrameRates) {
                            const targetRate = 30;
                            // Find closest supported rate to 30
                            const rates = Array.from(session.supportedFrameRates);
                            const bestRate = rates.reduce((prev, curr) => Math.abs(curr - targetRate) < Math.abs(prev - targetRate) ? curr : prev);
                            session.updateTargetFrameRate(bestRate).catch(e => console.log("Frame rate update failed", e));
                        }

                        // 2. Reduce Resolution drastically
                        // Rendering 3D content at 30% resolution. Passthrough camera remains sharp.
                        try {
                            const gl = renderer.getContext();
                            if (gl.makeXRCompatible) await gl.makeXRCompatible();
                            if (renderer.xr.setFramebufferScaleFactor) {
                                renderer.xr.setFramebufferScaleFactor(0.3); // Reduced from 0.5 to 0.3 for maximum battery saving
                            }
                        } catch(err) { console.log("Scale factor not supported"); }

                        renderer.setPixelRatio(1);
                        hideNonARUI(); preventAutoPositionInAR = true;
                        customArBtn.style.display = 'none'; fullscreenBtn.style.display = 'none'; exitBtn.style.display = 'none';
                        showToast("AR فعال شد");
                        session.addEventListener('end', () => {
                            preventAutoPositionInAR = false; showNonARUI(); try{ removeContentMeshes(); }catch(e){}
                            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(1);
                            isBgRemovalActive = false; removeBgBtn.classList.remove('active-mode');
                            currentSession = null; customArBtn.style.display = 'block'; exitBtn.style.display = 'flex';
                            resetAppToInitialState(); showToast("خروج از AR");
                        });
                    } catch (e) { console.error("AR Fail:", e); showToast("عدم پشتیبانی AR"); }
                }
            });
            window.addEventListener('resize', onWindowResize);
            setupUIListeners(); setupTouchGestures();
        }

        let lastFrameTime = 0;
        const FPS_LIMIT = 30;
        const FRAME_MIN_TIME = 1000 / FPS_LIMIT;

        function render(timestamp, frame) {
            if (renderer.xr.isPresenting) {
                // In AR, WebXR handles timing, but we limited frame rate and resolution above
                renderer.render(scene, camera);
            } else {
                // In 2D/Preview mode, strictly cap at 30 FPS
                if (timestamp - lastFrameTime >= FRAME_MIN_TIME) {
                    renderer.render(scene, camera);
                    lastFrameTime = timestamp;
                }
            }
        }
        
        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
        }

        function initMediaPipe() {
            setTimeout(() => {
                if (window.SelfieSegmentation) {
                    selfieSegmentation = new SelfieSegmentation({locateFile: (file) => `./js/mediapipe/${file}`});
                    selfieSegmentation.setOptions({ modelSelection: 0, selfieMode: false });
                    selfieSegmentation.onResults(onSegmentationResults);
                }
            }, 3000);
        }

        function setupUIListeners() {
            exitBtn.addEventListener('click', () => { 
                window.history.back();
            });
            
            aboutBtn.addEventListener('click', () => aboutModal.style.display = 'flex'); document.getElementById('close-about-btn').addEventListener('click', () => aboutModal.style.display = 'none');
            fileInput.addEventListener('click', (e) => { e.stopPropagation(); cleanSceneContent(); });
            fileInput.addEventListener('change', handleFileSelect);
            cleanViewBtn.addEventListener('click', () => { uiHidden = true; document.body.classList.add('ui-hidden'); showToast("منوها پنهان شدند"); });
            tempRevealBtn.addEventListener('click', () => revealUI());
            settingsBtn.addEventListener('click', () => settingsModal.style.display = 'flex'); document.getElementById('close-settings-btn').addEventListener('click', () => settingsModal.style.display = 'none');
            document.querySelectorAll('input[name="reveal-mode"]').forEach(radio => radio.addEventListener('change', (e) => revealMode = e.target.value));
            document.getElementById('help-btn').addEventListener('click', () => helpModal.style.display = 'flex'); document.getElementById('close-help-btn').addEventListener('click', () => helpModal.style.display = 'none');
            fullscreenBtn.addEventListener('click', () => { if (renderer.xr.isPresenting) return; if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); });
            playBtn.addEventListener('click', () => { if (currentVideo) { if (currentVideo.paused) { currentVideo.play(); playIcon.classList.add('hidden'); pauseIcon.classList.remove('hidden'); } else { currentVideo.pause(); playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden'); } } });
            seekBar.addEventListener('input', () => { if (currentVideo) currentVideo.currentTime = seekBar.value; });
            distSlider.addEventListener('input', (e) => { if (currentMesh) currentMesh.position.z = -parseFloat(e.target.value); });
            document.getElementById('reset-btn').addEventListener('click', () => { if (currentMesh) { distSlider.value = 1.0; try { const dir = new THREE.Vector3(); camera.getWorldDirection(dir); currentMesh.position.copy(camera.position).add(dir.multiplyScalar(1.0)); currentMesh.lookAt(camera.position); } catch(e) { currentMesh.position.set(0, 0, -1.0); currentMesh.rotation.set(0, 0, 0); } currentMesh.rotation.z = 0; initialRotationZ = 0; currentMesh.scale.set(1, 1, 1); isStretchMode = false; is3DMode = false; document.getElementById('stretch-btn').classList.remove('active-mode'); document.getElementById('mode-3d-btn').classList.remove('active-mode'); showToast("بازنشانی کامل"); } });
            cubeShapeBtn.addEventListener('click', () => { if (!currentMesh) return; isCubeMode = !isCubeMode; cubeShapeBtn.classList.toggle('active-mode', isCubeMode); try { currentMesh.geometry.dispose(); } catch(e){} if (isCubeMode) { currentMesh.geometry = new THREE.BoxGeometry(currentOriginalWidth*0.5, currentOriginalHeight*0.5, currentOriginalHeight*0.3); showToast("حالت مکعب"); } else { currentMesh.geometry = new THREE.PlaneGeometry(currentOriginalWidth, currentOriginalHeight, 1, 1); showToast("حالت تخت"); } });
            document.getElementById('mode-3d-btn').addEventListener('click', function() { is3DMode = !is3DMode; this.classList.toggle('active-mode', is3DMode); showToast(is3DMode ? "چرخش ۳ بعدی" : "حالت جابجایی"); });
            document.getElementById('rotate-btn').addEventListener('click', () => { if (currentMesh) currentMesh.rotation.z -= Math.PI / 2; });
            document.getElementById('aspect-btn').addEventListener('click', () => { if (!currentMesh) return; aspectRatioMode = (aspectRatioMode + 1) % 4; const scales = [1, 1.5, 1.5, 2]; const modes = ["سایز اصلی", "عریض", "مرتفع", "بزرگ"]; currentMesh.scale.set(aspectRatioMode===3?2:aspectRatioMode===1?1.5:1, aspectRatioMode===3?2:aspectRatioMode===2?1.5:1, 1); showToast(modes[aspectRatioMode]); });
            document.getElementById('stretch-btn').addEventListener('click', function() { isStretchMode = !isStretchMode; this.classList.toggle('active-mode', isStretchMode); showToast(isStretchMode ? "تغییر سایز آزاد" : "تغییر سایز قفل"); });
            removeBgBtn.addEventListener('click', toggleBgRemoval);
        }

        async function toggleBgRemoval() {
            if (!currentMesh) return;
            if (!selfieSegmentation) { showToast("صبر کنید (مدل لود نشد)..."); return; }
            isBgRemovalActive = !isBgRemovalActive; removeBgBtn.classList.toggle('active-mode', isBgRemovalActive);
            if (isBgRemovalActive) {
                showToast("حذف پس‌زمینه"); originalTexture = currentMesh.material.map;
                let w = currentVideo ? currentVideo.videoWidth : currentImageTexture.image.width;
                let h = currentVideo ? currentVideo.videoHeight : currentImageTexture.image.height;
                
                // OPTIMIZATION: Reduce canvas size for processing
                let scaleFactor = 1; if (w > TARGET_RESOLUTION) { scaleFactor = TARGET_RESOLUTION / w; w = TARGET_RESOLUTION; h = Math.floor(h * scaleFactor); }
                segmentationCanvas.width = w; segmentationCanvas.height = h;
                
                // Create texture with NO mipmaps to save GPU
                processedTexture = new THREE.CanvasTexture(segmentationCanvas); 
                processedTexture.colorSpace = THREE.SRGBColorSpace; 
                processedTexture.minFilter = THREE.LinearFilter; 
                processedTexture.magFilter = THREE.LinearFilter; 
                processedTexture.generateMipmaps = false; 
                
                currentMesh.material.map = processedTexture; currentMesh.material.transparent = true; currentMesh.material.needsUpdate = true;
                if (currentVideo) processVideoFrame(); else if (currentImageTexture) await selfieSegmentation.send({image: currentImageTexture.image});
            } else { showToast("حذف پس‌زمینه خاموش"); if (originalTexture) { currentMesh.material.map = originalTexture; currentMesh.material.transparent = false; currentMesh.material.needsUpdate = true; } if (processedTexture) { processedTexture.dispose(); processedTexture = null; } }
        }

        function onSegmentationResults(results) { if (!isBgRemovalActive) { isProcessing = false; return; } segmentationCtx.save(); segmentationCtx.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height); segmentationCtx.drawImage(results.segmentationMask, 0, 0, segmentationCanvas.width, segmentationCanvas.height); segmentationCtx.globalCompositeOperation = 'source-in'; segmentationCtx.drawImage(results.image, 0, 0, segmentationCanvas.width, segmentationCanvas.height); segmentationCtx.restore(); if (processedTexture) processedTexture.needsUpdate = true; isProcessing = false; }
        
        async function processVideoFrame() {
            if (!(isBgRemovalActive && currentVideo && !currentVideo.paused && !currentVideo.ended)) return;
            const now = performance.now();
            if (!isProcessing && (now - lastProcessTime > PROCESS_INTERVAL)) {
                isProcessing = true; lastProcessTime = now;
                try { await selfieSegmentation.send({image: currentVideo}); } catch(e) { isProcessing = false; }
            }
            requestAnimationFrame(processVideoFrame);
        }

        function revealUI() { uiHidden = false; document.body.classList.remove('ui-hidden'); tempRevealBtn.style.display = 'none'; }
        function handleFileSelect(event) {
            const file = event.target.files[0]; if (!file) return; cleanSceneContent(); const url = URL.createObjectURL(file); const fileType = file.type.split('/')[0];
            isBgRemovalActive = false; removeBgBtn.classList.remove('active-mode'); controlsPanel.classList.remove('hidden'); controlsPanel.classList.add('flex');
            document.getElementById('size-controls').classList.remove('hidden'); document.getElementById('size-controls').style.display = 'flex';
            cleanViewBtn.classList.remove('hidden'); if (!renderer.xr.isPresenting) fullscreenBtn.classList.remove('hidden'); distContainer.classList.remove('hidden'); fileLabel.querySelector('span').innerText = "تغییر فایل";
            if (fileType === 'image') { processImage(url); playBtn.style.display = 'none'; seekContainer.classList.add('hidden'); } 
            else if (fileType === 'video') { processVideo(url); playBtn.style.display = 'flex'; seekContainer.classList.remove('hidden'); playIcon.classList.add('hidden'); pauseIcon.classList.remove('hidden'); }
            event.target.value = '';
        }
        function processImage(url) { const loader = new THREE.TextureLoader(); loader.load(url, (texture) => { 
            texture.colorSpace = THREE.SRGBColorSpace; 
            texture.minFilter = THREE.LinearFilter; 
            texture.generateMipmaps = false; 
            currentImageTexture = texture; 
            createMesh(texture, texture.image.width, texture.image.height); 
        }); }
        function processVideo(url) { 
            const video = document.createElement('video'); try{ video.dataset.media = 'true'; }catch(e){} 
            video.src = url; video.crossOrigin = 'anonymous'; video.loop = true; video.playsInline = true; video.muted = false; 
            const playPromise = video.play(); 
            if (playPromise !== undefined) { playPromise.catch(error => { playIcon.classList.remove('hidden'); pauseIcon.classList.add('hidden'); }); } 
            currentVideo = video; 
            video.addEventListener('loadedmetadata', () => { 
                seekBar.max = video.duration; durationTimeEl.innerText = formatTime(video.duration); 
                const texture = new THREE.VideoTexture(video); 
                texture.colorSpace = THREE.SRGBColorSpace; 
                texture.minFilter = THREE.LinearFilter; 
                texture.magFilter = THREE.LinearFilter; 
                texture.format = THREE.RGBAFormat; 
                texture.generateMipmaps = false; 
                createMesh(texture, video.videoWidth, video.videoHeight); 
            }); 
            video.addEventListener('timeupdate', () => { seekBar.value = video.currentTime; currentTimeEl.innerText = formatTime(video.currentTime); }); 
            video.addEventListener('play', () => { if(isBgRemovalActive) processVideoFrame(); }); 
        }
        function createMesh(texture, width, height) { try{ removeContentMeshes(); }catch(e){} const aspectRatio = width / height; const displayHeight = 1.0; const displayWidth = displayHeight * aspectRatio; currentOriginalWidth = displayWidth; currentOriginalHeight = displayHeight; const geometry = new THREE.PlaneGeometry(displayWidth, displayHeight, 1, 1); const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: false }); currentMesh = new THREE.Mesh(geometry, material); currentMesh.name = 'contentMesh'; currentMesh.position.set(0, 0, -parseFloat(distSlider.value)); currentMesh.rotation.order = 'XYZ'; scene.add(currentMesh); showToast("فایل بارگذاری شد"); }
        function setupTouchGestures() {
            const el = document.body;
            el.addEventListener('touchstart', (e) => {
                if (e.target.closest('button') || e.target.closest('input') || e.target.closest('.modal')) return;
                // تغییر ۳ انگشت به ۴ انگشت
                if (uiHidden) { if (revealMode === 'gesture' && e.touches.length === 4) revealUI(); else if (revealMode === 'button') { tempRevealBtn.style.display = 'block'; if (revealTimer) clearTimeout(revealTimer); revealTimer = setTimeout(() => { tempRevealBtn.style.display = 'none'; }, 2000); } }
                if (e.touches.length === 1) { isDragging = true; previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } 
                else if (e.touches.length === 2 && currentMesh) { gestureType = null; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; initialPinchDistance = Math.sqrt(dx * dx + dy * dy); initialScale.copy(currentMesh.scale); initialAngle = Math.atan2(dy, dx); initialRotationZ = currentMesh.rotation.z; initialMidpoint = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 }; initialRotationX = currentMesh.rotation.x; initialRotationY = currentMesh.rotation.y; initialMeshPosition.copy(currentMesh.position); }
            }, { passive: false });
            el.addEventListener('touchmove', (e) => {
                if (!currentMesh || e.target.closest('.ui-bottom-controls') || e.target.closest('.modal')) return;
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) { const deltaX = e.touches[0].clientX - previousMousePosition.x; const deltaY = e.touches[0].clientY - previousMousePosition.y; if (is3DMode) { currentMesh.rotation.y += deltaX * 0.005; currentMesh.rotation.x += deltaY * 0.005; } else { currentMesh.position.x += deltaX * 0.0025; currentMesh.position.y -= deltaY * 0.0025; } previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY }; return; }
                if (e.touches.length === 2 && currentMesh) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const distance = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const currentMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2; const currentMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2; const scaleChange = Math.abs(distance - initialPinchDistance); const angleChange = Math.abs(angle - initialAngle); const panChange = Math.sqrt(Math.pow(currentMidX - initialMidpoint.x, 2) + Math.pow(currentMidY - initialMidpoint.y, 2));
                    if (!gestureType) { if (panChange > 15) gestureType = 'pan'; else if (scaleChange > 15) gestureType = 'zoom'; else if (angleChange > 0.1) gestureType = 'rotate'; }
                    if (gestureType === 'pan') { currentMesh.position.x = initialMeshPosition.x + (currentMidX - initialMidpoint.x) * 0.0025; currentMesh.position.y = initialMeshPosition.y - (currentMidY - initialMidpoint.y) * 0.0025; }
                    if (gestureType === 'zoom') { 
                        const scaleRatio = distance / initialPinchDistance; 
                        if (isStretchMode) { 
                            if (isCubeMode) {
                                // Logic for Cube Stretch based on view direction
                                const isHorizontalPinch = Math.abs(dx) > Math.abs(dy);
                                const rotationMatrix = new THREE.Matrix4().extractRotation(currentMesh.matrixWorld);
                                const origin = new THREE.Vector3(0,0,0).applyMatrix4(currentMesh.matrixWorld).project(camera);
                                
                                const pX = new THREE.Vector3(1,0,0).applyMatrix4(rotationMatrix).add(currentMesh.position).project(camera).sub(origin);
                                const pY = new THREE.Vector3(0,1,0).applyMatrix4(rotationMatrix).add(currentMesh.position).project(camera).sub(origin);
                                const pZ = new THREE.Vector3(0,0,1).applyMatrix4(rotationMatrix).add(currentMesh.position).project(camera).sub(origin);

                                let bestAxis = 'x';
                                let maxVal = 0;
                                
                                const check = (vec, axis) => {
                                    const val = isHorizontalPinch ? Math.abs(vec.x) : Math.abs(vec.y);
                                    if (val > maxVal) { maxVal = val; bestAxis = axis; }
                                };
                                
                                check(pX, 'x'); check(pY, 'y'); check(pZ, 'z');
                                currentMesh.scale[bestAxis] = initialScale[bestAxis] * scaleRatio;
                            } else {
                                if (Math.abs(dx) > Math.abs(dy)) currentMesh.scale.x = initialScale.x * scaleRatio; 
                                else currentMesh.scale.y = initialScale.y * scaleRatio; 
                            }
                        } 
                        else { currentMesh.scale.set(initialScale.x * scaleRatio, initialScale.y * scaleRatio, initialScale.z); } 
                    }
                    if (!is3DMode && (gestureType === 'rotate')) { currentMesh.rotation.z = initialRotationZ + (angle - initialAngle); }
                }
            }, { passive: false });
            el.addEventListener('touchend', () => { isDragging = false; gestureType = null; });
        }
    </script>
</body>
</html>